<!--  <?xml version="1.0" encoding="utf-8"?> -->
<questionbank>
     <item>
         <id>1</id>    
         <question>Which one of these lists contains only Java programming language keywords?</question>
         <ans1>class, if, void, long, Int, continue</ans1>
         <ans2>goto, instanceof, native, finally, default, throws</ans2>
         <ans3>try, virtual, throw, final, volatile, transient</ans3>
         <ans4>strictfp, constant, super, implements, do</ans4>
         <correctans>goto, instanceof, native, finally, default, throws</correctans>
         <description>All the words in option B are among the 49 Java keywords. Although goto reserved as a keyword in Java, goto is not used and has no function.
Option A is wrong because the keyword for the primitive int starts with a lowercase i.
Option C is wrong because "virtual" is a keyword in C++, but not Java.
Option D is wrong because "constant" is not a keyword. Constants in Java are marked static and final.
Option E is wrong because "include" is a keyword in C, but not in Java.</description>
     </item>
	      <item>
         <id>2</id>    
         <question>Which will legally declare, construct, and initialize an array?</question>
         <ans1>int [] myList = {"1", "2", "3"};</ans1>
         <ans2>int [] myList = (5, 8, 2);</ans2>
         <ans3>int myList [] [] = {4,9,7,0};</ans3>
         <ans4>int myList [] = {4, 3, 7};</ans4>
         <correctans>int myList [] = {4, 3, 7};</correctans>
         <description>The only legal array declaration and assignment statement is Option D
Option A is wrong because it initializes an int array with String literals.
Option B is wrong because it use something other than curly braces for the initialization.
Option C is wrong because it provides initial values for only one dimension, although the declared array is a two-dimensional array.</description>
     </item>
	      <item>
         <id>3</id>    
         <question>Which is a reserved word in the Java programming language?</question>
         <ans1>method</ans1>
         <ans2>native</ans2>
         <ans3>subclasses</ans3>
         <ans4>reference</ans4>
         <correctans>native</correctans>
         <description>The word "native" is a valid keyword, used to modify a method declaration.
Option A, D and E are not keywords. Option C is wrong because the keyword for subclassing in Java is extends, not 'subclasses'.</description>
     </item>
	      <item>
         <id>4</id>    
         <question>Which is a valid keyword in java?</question>
         <ans1>interface</ans1>
         <ans2>string</ans2>
         <ans3>Float</ans3>
         <ans4>unsigned</ans4>
         <correctans>interface</correctans>
         <description>interface is a valid keyword.
Option B is wrong because although "String" is a class type in Java, "string" is not a keyword.
Option C is wrong because "Float" is a class type. The keyword for the Java primitive is float.
Option D is wrong because "unsigned" is a keyword in C/C++ but not in Java.</description>
     </item>
	      <item>
         <id>5</id>    
         <question>public interface Foo 
{ 
    int k = 4; /* Line 3 */
}
Which three piece of codes are equivalent to line 3?
1. final int k = 4;
2. public int k = 4;
3. static int k = 4;
4. abstract int k = 4;
5. volatile int k = 4;
6. protected int k = 4;
</question>
         <ans1>1, 2 and 3</ans1>
         <ans2>2, 3 and 4</ans2>
         <ans3>3, 4 and 5</ans3>
         <ans4>4, 5 and 6</ans4>
         <correctans>1, 2 and 3</correctans>
         <description>(1), (2) and (3) are correct. Interfaces can have constants, which are always implicitly public, static, and final. Interface constant declarations of public, static, and final are optional in any combination.</description>
     </item>
	      <item>
         <id>6</id>    
         <question>Which one of the following will declare an array and initialize it with five numbers?</question>
         <ans1>Array a = new Array(5);</ans1>
         <ans2>int [] a = {23,22,21,20,19};</ans2>
         <ans3>int a [] = new int[5];</ans3>
         <ans4>int [5] array;</ans4>
         <correctans>int [] a = {23,22,21,20,19};</correctans>
         <description>Option B is the legal way to declare and initialize an array with five elements.
Option A is wrong because it shows an example of instantiating a class named Array, passing the integer value 5 to the object's constructor. If you don't see the brackets, you can be certain there is no actual array object! In other words, an Array object (instance of class Array) is not the same as an array object.
Option C is wrong because it shows a legal array declaration, but with no initialization.
Option D is wrong (and will not compile) because it declares an array with a size. Arrays must never be given a size when declared.</description>
     </item>
	      <item>
         <id>7</id>    
         <question>Which three are valid declarations of a char?

1. char c1 = 064770;
2. char c2 = 'face';
3. char c3 = 0xbeef;
4. char c4 = \u0022;
5. char c5 = '\iface';
6. char c6 = '\uface';</question>
         <ans1>1, 2, 4</ans1>
         <ans2>1, 3, 6</ans2>
         <ans3>3, 5</ans3>
         <ans4>5 only</ans4>
         <correctans>1, 3, 6</correctans>
         <description>(1), (3), and (6) are correct. char c1 = 064770; is an octal representation of the integer value 27128, which is legal because it fits into an unsigned 16-bit integer. char c3 = 0xbeef; is a hexadecimal representation of the integer value 48879, which fits into an unsigned 16-bit integer. char c6 = '\uface'; is a Unicode representation of a character.
char c2 = 'face'; is wrong because you can't put more than one character in a char literal. The only other acceptable char literal that can go between single quotes is a Unicode value, and Unicode literals must always start with a '\u'.
char c4 = \u0022; is wrong because the single quotes are missing.
char c5 = '\iface'; is wrong because it appears to be a Unicode representation (notice the backslash), but starts with '\i' rather than '\u'.</description>
     </item>
	      <item>
         <id>8</id>    
         <question>Which is the valid declarations within an interface definition?</question>
         <ans1>public double methoda();</ans1>
         <ans2>public final double methoda();</ans2>
         <ans3>static void methoda(double d1);</ans3>
         <ans4>protected void methoda(double d1);</ans4>
         <correctans>public double methoda();</correctans>
         <description></description>
     </item>
	      <item>
         <id>9</id>    
         <question>Which one is a valid declaration of a boolean?</question>
         <ans1>boolean b1 = 0;</ans1>
         <ans2>boolean b2 = 'false';</ans2>
         <ans3>boolean b3 = false;</ans3>
         <ans4>boolean b4 = Boolean.false();</ans4>
         <correctans>boolean b3 = false;</correctans>
         <description>A boolean can only be assigned the literal true or false</description>
     </item>
	      <item>
         <id>10</id>    
         <question>Which three are valid declarations of a float?
1. float f1 = -343;
2. float f2 = 3.14;
3. float f3 = 0x12345;
4. float f4 = 42e7;
5. float f5 = 2001.0D;
6. float f6 = 2.81F;
</question>
         <ans1>1, 2, 4</ans1>
         <ans2>2, 3, 5</ans2>
         <ans3>1, 3, 6</ans3>
         <ans4>2, 4, 6</ans4>
         <correctans>1, 3, 6</correctans>
         <description>1) and (3) are integer literals (32 bits), and integers can be legally assigned to floats (also 32 bits). (6) is correct because (F) is appended to the literal, declaring it as a float rather than a double (the default for floating point literals).
(2), (4),and (5) are all doubles.</description>
     </item>
	      <item>
         <id>11</id>    
         <question>Which is a valid declarations of a String?</question>
         <ans1>String s1 = null;</ans1>
         <ans2>String s2 = 'null';</ans2>
         <ans3>String s3 = (String) 'abc';</ans3>
         <ans4>String s4 = (String) '\ufeed';</ans4>
         <correctans>String s1 = null;</correctans>
         <description>Option A sets the String reference to null.
Option B is wrong because null cannot be in single quotes.
Option C is wrong because there are multiple characters between the single quotes ('abc').
Option D is wrong because you can't cast a char (primitive) to a String (object).</description>
     </item>
	      <item>
         <id>12</id>    
         <question><![CDATA[public void foo( boolean a, boolean b)
{ 
    if( a ) 
    {
        System.out.println("A"); /* Line 5 */
    } 
    else if(a && b) /* Line 7 */
    { 
        System.out.println( "A && B"); 
    } 
    else /* Line 11 */
    { 
        if ( !b ) 
        {
            System.out.println( "notB") ;
        } 
        else 
        {
            System.out.println( "ELSE" ) ; 
        } 
    } 
}]]></question>
         <ans1><![CDATA[If a is true and b is true then the output is "A && B"]]></ans1>
         <ans2>If a is true and b is false then the output is "notB"</ans2>
         <ans3>If a is false and b is true then the output is "ELSE"</ans3>
         <ans4>If a is false and b is false then the output is "ELSE"</ans4>
         <correctans>If a is false and b is true then the output is "ELSE"</correctans>
         <description><![CDATA[Option C is correct. The output is "ELSE". Only when a is false do the output lines after 11 get some chance of executing.
Option A is wrong. The output is "A". When a is true, irrespective of the value of b, only the line 5 output will be executed. The condition at line 7 will never be evaluated (when a is true it will always be trapped by the line 12 condition) therefore the output will never be "A && B".
Option B is wrong. The output is "A". When a is true, irrespective of the value of b, only the line 5 output will be executed.
Option D is wrong. The output is "notB".]]></description>
     </item>
	      <item>
         <id>13</id>    
         <question>switch(x) 
{ 
    default:  
        System.out.println("Hello"); 
}
Which two are acceptable types for x?
1.byte
2.long
3.char
4.float
5.Short
6.Long</question>
         <ans1>1 and 3</ans1>
         <ans2>2 and 4</ans2>
         <ans3>3 and 5</ans3>
         <ans4>4 and 6</ans4>
         <correctans>1 and 3</correctans>
         <description>Switch statements are based on integer expressions and since both bytes and chars can implicitly be widened to an integer, these can also be used. Also shorts can be used. Short and Long are wrapper classes and reference types can not be used as variables.</description>
     </item>
	      <item>
         <id>14</id>    
         <question>public void test(int x) 
{ 
    int odd = 1; 
    if(odd) /* Line 4 */
    {
        System.out.println("odd"); 
    } 
    else 
    {
        System.out.println("even"); 
    } 
}
Which statement is true?</question>
         <ans1>Compilation fails.</ans1>
         <ans2>"odd" will always be output.</ans2>
         <ans3>"even" will always be output.</ans3>
         <ans4>"odd" will be output for odd values of x, and "even" for even values.</ans4>
         <correctans>Compilation fails.</correctans>
         <description>The compiler will complain because of incompatible types (line 4), the if expects a boolean but it gets an integer.</description>
     </item>
	      <item>
         <id>15</id>    
         <question>public class While 
{
    public void loop() 
    {
        int x= 0;
        while ( 1 ) /* Line 6 */
        {
            System.out.print("x plus one is " + (x + 1)); /* Line 8 */
        }
    }
}
Which statement is true?</question>
         <ans1>There is a syntax error on line 1.</ans1>
         <ans2>There are syntax errors on lines 1 and 6.</ans2>
         <ans3>There are syntax errors on lines 1, 6, and 8.</ans3>
         <ans4>There is a syntax error on line 6.</ans4>
         <correctans>There is a syntax error on line 6.</correctans>
         <description>Using the integer 1 in the while statement, or any other looping or conditional construct for that matter, will result in a compiler error. This is old C Program syntax, not valid Java.

A, B and C are incorrect because line 1 is valid (Java is case sensitive so While is a valid class name). Line 8 is also valid because an equation may be placed in a String operation as shown.</description>
     </item>
	      <item>
         <id>16</id>    
         <question>Which is true about an anonymous inner class?</question>
         <ans1>It can extend exactly one class and implement exactly one interface.</ans1>
         <ans2>It can extend exactly one class and can implement multiple interfaces.</ans2>
         <ans3>It can extend exactly one class or implement exactly one interface.</ans3>
         <ans4>It can implement multiple interfaces regardless of whether it also extends a class.</ans4>
         <correctans>It can extend exactly one class or implement exactly one interface.</correctans>
         <description>ption C is correct because the syntax of an anonymous inner class allows for only one named type after the new, and that type must be either a single interface (in which case the anonymous class implements that one interface) or a single class (in which case the anonymous class extends that one class).
Option A, B, D, and E are all incorrect because they don't follow the syntax rules described in the response for answer Option C.</description>
     </item>
	      <item>
         <id>17</id>    
         <question>class Boo 
{
    Boo(String s) { }
    Boo() { }
}
class Bar extends Boo 
{
    Bar() { }
    Bar(String s) {super(s);}
    void zoo() 
    {
    // insert code here
    }
}
which one create an anonymous inner class from within class Bar?</question>
         <ans1>Boo f = new Boo(24) { };</ans1>
         <ans2>Boo f = new Bar() { };</ans2>
         <ans3>Bar f = new Boo(String s) { };</ans3>
         <ans4>Boo f = new Boo.Bar(String s) { };</ans4>
         <correctans>Boo f = new Bar() { };</correctans>
         <description>Option B is correct because anonymous inner classes are no different from any other class when it comes to polymorphism. That means you are always allowed to declare a reference variable of the superclass type and have that reference variable refer to an instance of a subclass type, which in this case is an anonymous subclass of Bar. Since Bar is a subclass of Boo, it all works.
Option A is incorrect because it passes an int to the Boo constructor, and there is no matching constructor in the Boo class.
Option C is incorrect because it violates the rules of polymorphismâ€”you cannot refer to a superclass type using a reference variable declared as the subclass type. The superclass is not guaranteed to have everything the subclass has.
Option D uses incorrect syntax.</description>
     </item>
	      <item>
         <id>18</id>    
         <question>Which is true about a method-local inner class?</question>
         <ans1>It must be marked final.</ans1>
         <ans2>It can be marked abstract.</ans2>
         <ans3>It can be marked public.</ans3>
         <ans4>It can be marked static.</ans4>
         <correctans>It can be marked abstract.</correctans>
         <description>Option B is correct because a method-local inner class can be abstract, although it means a subclass of the inner class must be created if the abstract class is to be used (so an abstract method-local inner class is probably not useful).
Option A is incorrect because a method-local inner class does not have to be declared final (although it is legal to do so).
C and D are incorrect because a method-local inner class cannot be made public (remember-you cannot mark any local variables as public), or static.</description>
     </item>
	      <item>
         <id>19</id>    
         <question>Which statement is true about a static nested class?</question>
         <ans1>You must have a reference to an instance of the enclosing class in order to instantiate it.</ans1>
         <ans2>It does not have access to nonstatic members of the enclosing class.</ans2>
         <ans3>It's variables and methods must be static.</ans3>
         <ans4>It must extend the enclosing class.</ans4>
         <correctans>It does not have access to nonstatic members of the enclosing class.</correctans>
         <description>Option B is correct because a static nested class is not tied to an instance of the enclosing class, and thus can't access the nonstatic members of the class (just as a static method can't access nonstatic members of a class).

Option A is incorrect because static nested classes do not need (and can't use) a reference to an instance of the enclosing class.

Option C is incorrect because static nested classes can declare and define nonstatic members.

Option D is wrong because it just is. There's no rule that says an inner or nested class has to extend anything.</description>
     </item>
	      <item>
         <id>20</id>    
         <question>Which constructs an anonymous inner class instance?</question>
         <ans1>Runnable r = new Runnable() { };</ans1>
         <ans2>Runnable r = new Runnable(public void run() { });</ans2>
         <ans3>Runnable r = new Runnable { public void run(){}};</ans3>
         <ans4>System.out.println(new Runnable() {public void run() { }});</ans4>
         <correctans>System.out.println(new Runnable() {public void run() { }});</correctans>
         <description>D is correct. It defines an anonymous inner class instance, which also means it creates an instance of that new anonymous class at the same time. The anonymous class is an implementer of the Runnable interface, so it must override the run() method of Runnable.

A is incorrect because it doesn't override the run() method, so it violates the rules of interface implementation.

B and C use incorrect syntax.</description>
     </item>
	      <item>
         <id>21</id>    
         <question>class Foo 
{
    class Bar{ }
}
class Test 
{
    public static void main (String [] args) 
    {
        Foo f = new Foo();
        /* Line 10: Missing statement ? */
    }
}
which statement, inserted at line 10, creates an instance of Bar?</question>
         <ans1>Foo.Bar b = new Foo.Bar();</ans1>
         <ans2>Foo.Bar b = f.new Bar();</ans2>
         <ans3>Bar b = new f.Bar();</ans3>
         <ans4>Bar b = f.new Bar();</ans4>
         <correctans>Foo.Bar b = f.new Bar();</correctans>
         <description>Option B is correct because the syntax is correct-using both names (the enclosing class and the inner class) in the reference declaration, then using a reference to the enclosing class to invoke new on the inner class.

Option A, C and D all use incorrect syntax. A is incorrect because it doesn't use a reference to the enclosing class, and also because it includes both names in the new.

C is incorrect because it doesn't use the enclosing class name in the reference variable declaration, and because the new syntax is wrong.

D is incorrect because it doesn't use the enclosing class name in the reference variable declaration.</description>
     </item>
	      <item>
         <id>22</id>    
         <question>public class MyOuter 
{
    public static class MyInner 
    {
        public static void foo() { }
    }
}
which statement, if placed in a class other than MyOuter or MyInner, instantiates an instance of the nested class?</question>
         <ans1>MyOuter.MyInner m = new MyOuter.MyInner();</ans1>
         <ans2>MyOuter.MyInner mi = new MyInner();</ans2>
         <ans3>MyOuter.MyInner mi = m.new MyOuter.MyInner();</ans3>
         <ans4>MyInner mi = new MyOuter.MyInner();</ans4>
         <correctans>MyOuter.MyInner m = new MyOuter.MyInner();</correctans>
         <description>MyInner is a static nested class, so it must be instantiated using the fully-scoped name of MyOuter.MyInner.

Option B is incorrect because it doesn't use the enclosing name in the new.

Option C is incorrect because it uses incorrect syntax. When you instantiate a nested class by invoking new on an instance of the enclosing class, you do not use the enclosing name. The difference between Option A and C is that Option C is calling new on an instance of the enclosing class rather than just new by itself.

Option D is incorrect because it doesn't use the enclosing class name in the variable declaration.</description>
     </item>
	      <item>
         <id>23</id>    
         <question>What will be the output of the program?
public class Test 
{  
    public static void main(String[] args) 
    { 
        int x = 0;  
        assert (x > 0) ? "assertion failed" : "assertion passed" ; 
        System.out.println("finished");  
    } 
}
</question>
         <ans1>finished</ans1>
         <ans2>Compiliation fails.</ans2>
         <ans3>An AssertionError is thrown and finished is output.</ans3>
         <ans4>An AssertionError is thrown with the message "assertion failed."</ans4>
         <correctans>Compiliation fails.</correctans>
         <description>Compilation Fails. You can't use the Assert statement in a similar way to the ternary operator. Don't confuse.</description>
     </item>
	      <item>
         <id>24</id>    
         <question>public class Test 
{ 
    public void foo() 
    {
        assert false; /* Line 5 */
        assert false; /* Line 6 */
    } 
    public void bar()
    {
        while(true)
        {
            assert false; /* Line 12 */
        } 
        assert false;  /* Line 14 */
    } 
}
What causes compilation to fail?</question>
         <ans1>Line 5</ans1>
         <ans2>Line 6</ans2>
         <ans3>Line 12</ans3>
         <ans4>Line 14</ans4>
         <correctans>Line 14</correctans>
         <description>Option D is correct. Compilation fails because of an unreachable statement at line 14. It is a compile-time error if a statement cannot be executed because it is unreachable. The question is now, why is line 20 unreachable? If it is because of the assert then surely line 6 would also be unreachable. The answer must be something other than assert.

Examine the following:

A while statement can complete normally if and only if at least one of the following is true:

- The while statement is reachable and the condition expression is not a constant expression with value true.

-There is a reachable break statement that exits the while statement.

The while statement at line 11 is infinite and there is no break statement therefore line 14 is unreachable. You can test this with the following code:
public class Test80 
{ 
    public void foo() 
    {
        assert false; 
        assert false; 
    } 
    public void bar()
    {
        while(true)
        {
            assert false; 
            break; 
        } 
        assert false;  
    } 
}</description>

     </item>
	      <item>
         <id>25</id>    
         <question>What will be the output of the program?

public class Test 
{
    public static int y;
    public static void foo(int x) 
    {
        System.out.print("foo ");
        y = x;
    }
    public static int bar(int z) 
    {
        System.out.print("bar ");
        return y = z;
    }
    public static void main(String [] args ) 
    {
        int t = 0;
        assert t > 0 : bar(7);
        assert t > 1 : foo(8); /* Line 18 */
        System.out.println("done ");
    }
}</question>
         <ans1>bar</ans1>
         <ans2>bar done</ans2>
         <ans3>foo done</ans3>
         <ans4>Compilation fails</ans4>
         <correctans>Compilation fails</correctans>
         <description>The foo() method returns void. It is a perfectly acceptable method, but because it returns void it cannot be used in an assert statement, so line 18 will not compile.</description>
     </item>
	      <item>
         <id>26</id>    
         <question>What will be the output of the program (when you run with the -ea option) ?

public class Test 
{  
    public static void main(String[] args) 
    {
        int x = 0;  
        assert (x > 0) : "assertion failed"; /* Line 6 */
        System.out.println("finished"); 
    } 
}</question>
         <ans1>finished</ans1>
         <ans2>Compilation fails.</ans2>
         <ans3>An AssertionError is thrown.</ans3>
         <ans4>An AssertionError is thrown and finished is output.</ans4>
         <correctans>An AssertionError is thrown.</correctans>
         <description>An assertion Error is thrown as normal giving the output "assertion failed". The word "finished" is not printed (ensure you run with the -ea option)

Assertion failures are generally labeled in the stack trace with the file and line number from which they were thrown, and also in this case with the error's detail message "assertion failed". The detail message is supplied by the assert statement in line 6.</description>
     </item>
	 <item>
         <id>27</id>    
         <question><![CDATA[public class Test2 
{
    public static int x;
    public static int foo(int y) 
    {
        return y * 2;
    }
    public static void main(String [] args) 
    {
        int z = 5;
        assert z > 0; /* Line 11 */
        assert z > 2: foo(z); /* Line 12 */
        if ( z < 7 )
            assert z > 4; /* Line 14 */

        switch (z) 
        {
            case 4: System.out.println("4 ");
            case 5: System.out.println("5 ");
            default: assert z < 10;
        }

        if ( z < 10 )
            assert z > 4: z++; /* Line 22 */
        System.out.println(z);
    }
}
which line is an example of an inappropriate use of assertions?]]>
</question>
         <ans1>Line 11</ans1>
         <ans2>Line 12</ans2>
         <ans3>Line 14</ans3>
         <ans4>Line 22</ans4>
         <correctans>Line 22</correctans>
         <description>Assert statements should not cause side effects. Line 22 changes the value of z if the assert statement is false.

Option A is fine; a second expression in an assert statement is not required.

Option B is fine because it is perfectly acceptable to call a method with the second expression of an assert statement.

Option C is fine because it is proper to call an assert statement conditionally.</description>
     </item>
	 
</questionbank>
